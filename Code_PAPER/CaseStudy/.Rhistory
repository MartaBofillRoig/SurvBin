# Calculate the integral: int_{t,tau}(weight * surv)
Integral1 <- cumsum(diff(c(0, fail_times)) * weight * KMpooled)
Int <- (Integral1[l] - Integral1)
# Calculate the estimated (pooled) variance
var_inside = ifelse(preKMpooled*KMpooled==0, 0, Int^2*(w)^(-1)*KMp_jumps/(preKMpooled*KMpooled))
variance =  -sum(var_inside,na.rm = TRUE)
}
stdev <- sqrt(variance)
# Standardized statistic
WKMtest <- WKM/stdev
if(is.null(tau)){
return(list=c(Test=WKMtest,Us=WKM,sd=stdev))
}else{
return(list=c(Test=WKMtest,Us=WKM,sd=stdev,tau=round(tau,2)))
}
}
require(zoo)
require(survival)
require(muhaz)
B <- bintest(binary=data$binary, treat=data$treat, var_est = "Pooled")
B[1]
S <- survtest(time=data$time, status=data$status, treat=data$treat, tau=4, rho=0, gam=1, eta=1, var_est = "Pooled")
S[1]
S <- survtest(time=data$time, status=data$status, treat=data$treat, tau=4, rho=0, gam=1, eta=1, var_est = "Unpooled")
S[1]
sigma_sb <- survbinCov(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, var_est = "Pooled")
sigma_sb
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Pooled")
z_sb
# z_sb[1]
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Unpooled")
z_sb
# z_sb[1]
z_sb = lstats_boots(data$time, data$status, data$binary, data$treat, tau=4, rho=0, gam=1, eta=1, wb=0.25, ws=0.75,
Boot = 100)
z_sb
load("C:/Users/mbofi/Dropbox/C5/Scripts/GitKraken/survivalbinary/Code_PAPER/CaseStudy/DigitizeIt/Dataset_Survival.RData")
set.seed(2020)
n0=dim(pbo_IPD)[1]
n1=dim(trt_IPD)[1]
prob1 = 5.7/100
prob0 = 1.5/100
v0 = runif(n=n0)
v1 = runif(n=n1)
BE0 = ifelse(v0<prob0, 1, 0)
BE1 = ifelse(v1<prob1, 1, 0)
trt_data = data.frame(treat=trt_IPD$arm, time=trt_IPD$time, status=trt_IPD$status, binary = BE1)
tbo_data = data.frame(treat=pbo_IPD$arm, time=pbo_IPD$time, status=pbo_IPD$status, binary = BE0)
data = rbind(trt_data, tbo_data)
head(data)
######################################
sum(subset(data, data$treat==1)$binary)/n1
sum(subset(data, data$treat==0)$binary)/n0
######################################
# PLOTS KAPLAN-MEIER ESTIMATORS
######################################
library(rms)
windows()
fit.rms <- npsurv(survival::Surv(time, status) ~ arm, data=recon_IPD)
survplot(fit  = fit.rms,
conf = c("none","bands","bars")[2],
xlab = "Time in years", ylab = "Overall Survival",
xlim=c(0,5),
# label.curves = TRUE,                     # label curves directly
label.curves = list(keys = "lines"),  # legend instead of direct label
levels.only  = FALSE,                    # show only levels, no label
abbrev.label = FALSE,                    # if label used, abbreviate
## fun = function(x) {1 - x},            # Cumulative probability plot
loglog   = FALSE,                        # log(-log Survival) plot
logt     = FALSE,                        # log time
time.inc = 1,                          # time increment
dots     = TRUE,                         # dot grid
n.risk   = TRUE,                          # show number at risk
cex.n.risk=0.7,
col=c("coral1","chartreuse4"),lwd=2,lty=1,legend.pos = "topright"
)
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Pooled")
z_sb
# z_sb[1]
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Unpooled")
z_sb
# z_sb[1]
z_sb = lstats_boots(data$time, data$status, data$binary, data$treat, tau=4, rho=0, gam=1, eta=1, wb=0.25, ws=0.75,
Boot = 50)
z_sb
setwd("C:/Users/mbofi/Dropbox/C5/Scripts/GitKraken/survivalbinary/Code_PAPER/CaseStudy")
load("C:/Users/mbofi/Dropbox/C5/Scripts/GitKraken/survivalbinary/Code_PAPER/CaseStudy/DigitizeIt/Dataset_Survival.RData")
set.seed(2020)
n0=dim(pbo_IPD)[1]
n1=dim(trt_IPD)[1]
prob1 = 5.7/100
prob0 = 1.5/100
v0 = runif(n=n0)
v1 = runif(n=n1)
BE0 = ifelse(v0<prob0, 1, 0)
BE1 = ifelse(v1<prob1, 1, 0)
trt_data = data.frame(treat=trt_IPD$arm, time=trt_IPD$time, status=trt_IPD$status, binary = BE1)
tbo_data = data.frame(treat=pbo_IPD$arm, time=pbo_IPD$time, status=pbo_IPD$status, binary = BE0)
data = rbind(trt_data, tbo_data)
head(data)
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Pooled")
z_sb
# z_sb[1]
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Unpooled")
z_sb
# z_sb[1]
z_sb = lstats_boots(data$time, data$status, data$binary, data$treat, tau=4, rho=0, gam=1, eta=1, wb=0.25, ws=0.75,
Boot = 100)
z_sb
rm(list = ls())
# setwd("C:/Users/Marta/Nextcloud/Gitkraken/SurvBin/Code_PAPER/CaseStudy")
# load("C:/Users/Marta/Nextcloud/Gitkraken/SurvBin/Code_PAPER/CaseStudy/DigitizeIt/Dataset_Survival.RData")
setwd("C:/Users/mbofi/Dropbox/C5/Scripts/GitKraken/survivalbinary/Code_PAPER/CaseStudy")
load("C:/Users/mbofi/Dropbox/C5/Scripts/GitKraken/survivalbinary/Code_PAPER/CaseStudy/DigitizeIt/Dataset_Survival.RData")
set.seed(2020)
n0=dim(pbo_IPD)[1]
n1=dim(trt_IPD)[1]
prob1 = 5.7/100
prob0 = 1.5/100
v0 = runif(n=n0)
v1 = runif(n=n1)
BE0 = ifelse(v0<prob0, 1, 0)
BE1 = ifelse(v1<prob1, 1, 0)
trt_data = data.frame(treat=trt_IPD$arm, time=trt_IPD$time, status=trt_IPD$status, binary = BE1)
tbo_data = data.frame(treat=pbo_IPD$arm, time=pbo_IPD$time, status=pbo_IPD$status, binary = BE0)
data = rbind(trt_data, tbo_data)
head(data)
######################################
sum(subset(data, data$treat==1)$binary)/n1
sum(subset(data, data$treat==0)$binary)/n0
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Pooled")
z_sb
# z_sb[1]
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Unpooled")
z_sb
# z_sb[1]
z_sb = lstats_boots(data$time, data$status, data$binary, data$treat, tau=4, rho=0, gam=1, eta=1, wb=0.25, ws=0.75,
Boot = 30)
z_sb
rm(list = ls())
# setwd("C:/Users/Marta/Nextcloud/Gitkraken/SurvBin/Code_PAPER/CaseStudy")
# load("C:/Users/Marta/Nextcloud/Gitkraken/SurvBin/Code_PAPER/CaseStudy/DigitizeIt/Dataset_Survival.RData")
setwd("C:/Users/mbofi/Dropbox/C5/Scripts/GitKraken/survivalbinary/Code_PAPER/CaseStudy")
load("C:/Users/mbofi/Dropbox/C5/Scripts/GitKraken/survivalbinary/Code_PAPER/CaseStudy/DigitizeIt/Dataset_Survival.RData")
set.seed(2020)
n0=dim(pbo_IPD)[1]
n1=dim(trt_IPD)[1]
prob1 = 5.7/100
prob0 = 1.5/100
v0 = runif(n=n0)
v1 = runif(n=n1)
BE0 = ifelse(v0<prob0, 1, 0)
BE1 = ifelse(v1<prob1, 1, 0)
trt_data = data.frame(treat=trt_IPD$arm, time=trt_IPD$time, status=trt_IPD$status, binary = BE1)
tbo_data = data.frame(treat=pbo_IPD$arm, time=pbo_IPD$time, status=pbo_IPD$status, binary = BE0)
data = rbind(trt_data, tbo_data)
head(data)
######################################
sum(subset(data, data$treat==1)$binary)/n1
sum(subset(data, data$treat==0)$binary)/n0
######################################
# PLOTS KAPLAN-MEIER ESTIMATORS
######################################
library(rms)
windows()
fit.rms <- npsurv(survival::Surv(time, status) ~ arm, data=recon_IPD)
survplot(fit  = fit.rms,
conf = c("none","bands","bars")[2],
xlab = "Time in years", ylab = "Overall Survival",
xlim=c(0,5),
# label.curves = TRUE,                     # label curves directly
label.curves = list(keys = "lines"),  # legend instead of direct label
levels.only  = FALSE,                    # show only levels, no label
abbrev.label = FALSE,                    # if label used, abbreviate
## fun = function(x) {1 - x},            # Cumulative probability plot
loglog   = FALSE,                        # log(-log Survival) plot
logt     = FALSE,                        # log time
time.inc = 1,                          # time increment
dots     = TRUE,                         # dot grid
n.risk   = TRUE,                          # show number at risk
cex.n.risk=0.7,
col=c("coral1","chartreuse4"),lwd=2,lty=1,legend.pos = "topright"
)
lstats <- function(time, status, binary, treat, tau0=0, tau=NULL, taub=NULL, rho=0, gam=0, eta=1, wb=0.5, ws=0.5, var_est="Unpooled"){
db=cbind.data.frame(time=time, status=status, binary=binary, treat=treat)
db1=subset(db,db$treat==1)
db0=subset(db,db$treat==0)
n1=dim(db1)[1]
n0=dim(db0)[1]
n=n0+n1
# KAPLAN-MEIER ESTIMATORS
######################################
B <- bintest(db$binary, db$treat, var_est)
test_b <- B[1]
sigma_b <- B[3]
S <- survtest(db$time, db$status, db$treat, tau, rho, gam, eta, var_est)
test_s <- S[1]
sigma_s <- S[3]
sigma_sb <- survbinCov(db$time,db$status,db$binary,db$treat, tau0, tau, taub, rho, gam, eta, var_est)
# Calculate the statistic
u_bs = wb*test_b + ws*test_s
# Calculate the estimated variance
variance =  wb^2 + ws^2 + 2*wb*ws*sigma_sb/(sigma_b*sigma_s)
stdev <- sqrt(variance)
test_l <- u_bs/stdev
# return(list=c(LTest=test_l,Statistic=u_bs,sd=stdev))
output <- data.frame(Parameter=c("(Standardized) L-Test","L-Test", "Standard deviation"),
Value=c(test_l, u_bs, stdev))
output_bin <- data.frame(Parameter=c("Standardized L-Test","Binary Test", "Standard deviation"),
Value=c(B[1], B[2], B[3]))
output_surv <- data.frame(Parameter=c("Standardized Test","Survival Test", "Standard deviation"),
Value=c(S[1], S[2], S[3]))
return(list(LTest=output,Binary_Tests=output_bin,Survival_Tests=output_surv))
}
survtest <- function(time, status, treat, tau=NULL, rho=0, gam=0, eta=1,var_est='Unpooled'){
# require(zoo) # 'rollmean' function
# require(survival)
db=cbind.data.frame(time=time, status=status, treat=treat)
db1=subset(db,db$treat==1)
db0=subset(db,db$treat==0)
n1=dim(db1)[1]
n0=dim(db0)[1]
n=n0+n1
# KAPLAN-MEIER ESTIMATORS
######################################
# Estimation of the KM curve
km1 <- survfit(Surv(time=time,event=status)~1, data=db1)
km0 <- survfit(Surv(time=time,event=status)~1, data=db0)
# Estimation of the pooled KM curve
kmp <- survfit(Surv(time, status) ~ 1, data = db)
# Estimation of the KM curve for the time-to-censoring
censkm1 <- survfit(Surv(time=time,status==0)~1, data = db1)
censkm0 <- survfit(Surv(time=time,status==0)~1, data = db0)
# Kaplan-Meier function
km1_f <- stepfun(km1$time, c(1, km1$surv))
km0_f <- stepfun(km0$time, c(1, km0$surv))
kmp_f <- stepfun(kmp$time, c(1, kmp$surv))
# Censoring Kaplan-Meier function
censkm1_f <- stepfun(censkm1$time, c(1, censkm1$surv))
censkm0_f <- stepfun(censkm0$time, c(1, censkm0$surv))
# TIMEPOINTS FOR INTEGRALS' COMPUTATION
###########################################
# Failure and censoring times
fail_times <- sort(db$time)
l1=length(km1$time)
l0=length(km0$time)
# Define the last time
if(is.null(tau)){
fail_times <- sort(c(db$time))
}else{
fail_times <- sort(c(db$time, tau))
fail_times <- fail_times[fail_times<=tau]
}
# Delete duplicates
fail_times <- fail_times[!duplicated(fail_times)]
# Define the midpoint between failures times
midfail_times <- rollmean(c(0, fail_times), 2)
# number of distinct ordered observed failures times
l=length(fail_times)
# WEIGHTED KAPLAN-MEIER STATISTIC
#######################################################
# Kaplan-Meier estimates' values at midpoints between event times (failure and censoring times)
KM0 <- km0_f(fail_times)
KM1 <- km1_f(fail_times)
preKM0 <- km0_f(midfail_times)
preKM1 <- km1_f(midfail_times)
preKM <- kmp_f(midfail_times)
preKM0_cens <- censkm0_f(midfail_times)
preKM1_cens <- censkm1_f(midfail_times)
KMpooled <- kmp_f(fail_times)
preKMpooled <- kmp_f(midfail_times)
# Compute the weight function
######################################
# weight function proposed by Pepe-Fleming
w <- ifelse(preKM0_cens+preKM1_cens == 0, 0, (n*preKM0_cens*preKM1_cens)/(n0*preKM0_cens + n1*preKM1_cens))
# weight function proposed by Fleming-Harrington
f <- ifelse(preKM0+preKM1 == 0, 0, (n*preKM0*preKM1)/(n0*preKM0 + n1*preKM1))
# Define the weight function as a product of w and f
weight <- w^(eta)*f^rho*(1-f)^gam
# Weighted Kaplan-Meier Statistic
######################################
WKM <- sqrt((n0*n1)/n)*sum(weight*(preKM1-preKM0)*diff(c(0, fail_times)), na.rm = TRUE)
# Variance computation
######################################
if(var_est=='Unpooled'){
# Kaplan-Meier jumps
# group 0
KM0_jumps <- diff(c(1,km0_f(fail_times)))
# group 1
KM1_jumps <- diff(c(1,km1_f(fail_times)))
# Calculate the integral: int_{t,tau}(weight * surv)
# group 0
Integral0 <- cumsum(diff(c(0, fail_times)) * weight * km0_f(fail_times))
Int0 <- (Integral0[l] - Integral0)
# group 1
Integral1 <- cumsum(diff(c(0, fail_times)) * weight * km1_f(fail_times))
Int1 <- (Integral1[l] - Integral1)
# Calculate the estimated (unpooled) variance
var_inside0 = ifelse(preKM0*KM0==0, 0, Int0^2*(w)^(-1)*KM0_jumps/(preKM0*KM0))
var_inside1 = ifelse(preKM1*KM1==0, 0, Int1^2*(w)^(-1)*KM1_jumps/(preKM1*KM1))
variance = (-n1*(sum(var_inside0,na.rm = TRUE))-
n0*(sum(var_inside1,na.rm = TRUE)))/n
}else{
KMp_jumpsaux <- c(1,kmp_f(fail_times))
KMp_jumps <- as.numeric(l)
for(i in 2:(l+1)){
KMp_jumps[i-1] = KMp_jumpsaux[i]-KMp_jumpsaux[i-1]
}
# Calculate the integral: int_{t,tau}(weight * surv)
Integral1 <- cumsum(diff(c(0, fail_times)) * weight * KMpooled)
Int <- (Integral1[l] - Integral1)
# Calculate the estimated (pooled) variance
var_inside = ifelse(preKMpooled*KMpooled==0, 0, Int^2*(w)^(-1)*KMp_jumps/(preKMpooled*KMpooled))
variance =  -sum(var_inside,na.rm = TRUE)
}
stdev <- sqrt(variance)
# Standardized statistic
WKMtest <- WKM/stdev
if(is.null(tau)){
return(list=c(Test=WKMtest,Us=WKM,sd=stdev))
}else{
return(list=c(Test=WKMtest,Us=WKM,sd=stdev,tau=round(tau,2)))
}
}
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Pooled")
z_sb
# z_sb[1]
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Unpooled")
z_sb
# z_sb[1]
z_sb = lstats_boots(data$time, data$status, data$binary, data$treat, tau=4, rho=0, gam=1, eta=1, wb=0.25, ws=0.75,
Boot = 50)
z_sb
lstats_boots <- function(time, status, binary, treat, tau, rho=0, gam=0, eta=1, wb=0.5, ws=0.5, Boot=50){
db=cbind.data.frame(time=time, status=status, binary=binary, treat=treat)
db1=subset(db,db$treat==1)
db0=subset(db,db$treat==0)
n1=dim(db1)[1]
n0=dim(db0)[1]
n=n0+n1
# KAPLAN-MEIER ESTIMATORS
######################################
B <- bintest(db$binary, db$treat)
test_b <- B[1]
sigma_b <- B[3]
S <- survtest(db$time, db$status, db$treat, tau, rho, gam, eta)
test_s <- S[1]
sigma_s <- S[3]
# Calculate the statistic
u_bs = wb*test_b + ws*test_s
# bootstrap
# B=50
ubs_boot <- data.frame(0)
for(i in 1:Boot){
daux <- db[sample(1:nrow(db),nrow(db),rep=TRUE),]
btt <- bintest(daux$binary, daux$treat)[1]
stt <- survtest(daux$time, daux$status, daux$treat)[1]
ubs_boot[i] = wb*btt + ws*stt
}
stdev <- sd(ubs_boot)
test_l <- u_bs/stdev
# return(list=c(LTest=test_l,Statistic=u_bs,sd=stdev))
output <- data.frame(Parameter=c("(Standardized) L-Test","L-Test", "Standard deviation"),
Value=c(test_l, u_bs, stdev))
output_bin <- data.frame(Parameter=c("Standardized L-Test","Binary Test", "Standard deviation"),
Value=c(B[1], B[2], B[3]))
output_surv <- data.frame(Parameter=c("Standardized Test","Survival Test", "Standard deviation"),
Value=c(S[1], S[2], S[3]))
return(list(LTest=output,Binary_Tests=output_bin,Survival_Tests=output_surv))
}
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Pooled")
z_sb
# z_sb[1]
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Unpooled")
z_sb
# z_sb[1]
z_sb = lstats_boots(data$time, data$status, data$binary, data$treat, tau=4, rho=0, gam=1, eta=1, wb=0.25, ws=0.75,
Boot = 50)
z_sb
setwd("C:/Users/mbofi/Dropbox/C5/Scripts/GitKraken/survivalbinary/Code_PAPER/CaseStudy")
load("C:/Users/mbofi/Dropbox/C5/Scripts/GitKraken/survivalbinary/Code_PAPER/CaseStudy/DigitizeIt/Dataset_Survival.RData")
set.seed(2020)
n0=dim(pbo_IPD)[1]
n1=dim(trt_IPD)[1]
prob1 = 5.7/100
prob0 = 1.5/100
v0 = runif(n=n0)
v1 = runif(n=n1)
BE0 = ifelse(v0<prob0, 1, 0)
BE1 = ifelse(v1<prob1, 1, 0)
trt_data = data.frame(treat=trt_IPD$arm, time=trt_IPD$time, status=trt_IPD$status, binary = BE1)
tbo_data = data.frame(treat=pbo_IPD$arm, time=pbo_IPD$time, status=pbo_IPD$status, binary = BE0)
data = rbind(trt_data, tbo_data)
head(data)
######################################
sum(subset(data, data$treat==1)$binary)/n1
sum(subset(data, data$treat==0)$binary)/n0
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Pooled")
z_sb
# z_sb[1]
z_sb = lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Unpooled")
z_sb
# z_sb[1]
z_sb = lstats_boots(data$time, data$status, data$binary, data$treat, tau=4, rho=0, gam=1, eta=1, wb=0.25, ws=0.75,
Boot = 100)
z_sb
lstats(time=data$time, status=data$status, binary=data$binary, treat=data$treat, tau0=0, tau=4, taub=0.5, rho=0, gam=1, eta=1, wb=0.25, ws=0.75, var_est = "Unpooled")
bintest(binary=data$binary, treat=data$treat, var_est = "Pooled")
library(SurvBin)
bintest(binary=data$binary, treat=data$treat, var_est = "Pooled")
bintest(binary=data$binary, treat=data$treat, var_est = "Unpooled")
0.4540763/0.2431064
bintest <- function(binary,treat,var_est='Unpooled'){
db=cbind.data.frame(binary=binary, treat=treat)
db1=subset(db,db$treat==1)
db0=subset(db,db$treat==0)
n1=dim(db1)[1]
n0=dim(db0)[1]
n=n0+n1
# BINARY TEST
######################################
phat_group0 = sum(subset(db, db$treat==0)$binary)/n0
phat_group1 = sum(subset(db, db$treat==1)$binary)/n1
phat_pooled = (phat_group0*n0 + phat_group1*n1)/n
if(var_est=='Unpooled'){
var.bin= phat_group0*(1-phat_group0)/n0+phat_group1*(1-phat_group1)/n1
}else{
var.bin = (n/(n0*n1))*phat_pooled*(1-phat_pooled)
}
Zb = (phat_group1-phat_group0)/sqrt(var.bin)
return(list=c(Test=Zb,Ub=sqrt((n0*n1)/n)*(phat_group1-phat_group0),sd=sqrt(var.bin/((n0*n1)/n))))
# return(list=c(Test=Zb,Ub=sqrt((n0*n1)/n)*(phat_group1-phat_group0),sd=sqrt(phat_pooled*(1-phat_pooled))  ))
}
bintest(binary=data$binary, treat=data$treat, var_est = "Pooled")
0.45/0.002
bintest(binary=data$binary, treat=data$treat, var_est = "Unpooled")
0.45/0.001
bintest <- function(binary,treat,var_est='Unpooled'){
db=cbind.data.frame(binary=binary, treat=treat)
db1=subset(db,db$treat==1)
db0=subset(db,db$treat==0)
n1=dim(db1)[1]
n0=dim(db0)[1]
n=n0+n1
# BINARY TEST
######################################
phat_group0 = sum(subset(db, db$treat==0)$binary)/n0
phat_group1 = sum(subset(db, db$treat==1)$binary)/n1
phat_pooled = (phat_group0*n0 + phat_group1*n1)/n
if(var_est=='Unpooled'){
var.bin= phat_group0*(1-phat_group0)/n0+phat_group1*(1-phat_group1)/n1
}else{
var.bin = (n/(n0*n1))*phat_pooled*(1-phat_pooled)
}
Zb = (phat_group1-phat_group0)/sqrt(var.bin)
# return(list=c(Test=Zb,Ub=sqrt((n0*n1)/n)*(phat_group1-phat_group0),sd=sqrt(var.bin/((n0*n1)/n))))
return(list=c(Test=Zb,Ub=sqrt((n0*n1)/n)*(phat_group1-phat_group0),sd=sqrt(var.bin)  ))
}
bintest(binary=data$binary, treat=data$treat, var_est = "Unpooled")
0.45/0.019
bintest <- function(binary,treat,var_est='Unpooled'){
db=cbind.data.frame(binary=binary, treat=treat)
db1=subset(db,db$treat==1)
db0=subset(db,db$treat==0)
n1=dim(db1)[1]
n0=dim(db0)[1]
n=n0+n1
# BINARY TEST
######################################
phat_group0 = sum(subset(db, db$treat==0)$binary)/n0
phat_group1 = sum(subset(db, db$treat==1)$binary)/n1
phat_pooled = (phat_group0*n0 + phat_group1*n1)/n
if(var_est=='Unpooled'){
var.bin= phat_group0*(1-phat_group0)/n0+phat_group1*(1-phat_group1)/n1
}else{
var.bin = (n/(n0*n1))*phat_pooled*(1-phat_pooled)
}
Zb = (phat_group1-phat_group0)/sqrt(var.bin)
# return(list=c(Test=Zb,Ub=sqrt((n0*n1)/n)*(phat_group1-phat_group0),sd=sqrt(var.bin/((n0*n1)/n))))
return(list=c(Test=Zb,Ub=sqrt((n0*n1)/n)*(phat_group1-phat_group0),sd=sqrt(var.bin/(n/(n0*n1)))  ))
}
bintest(binary=data$binary, treat=data$treat, var_est = "Unpooled")
0.45/0.19
bintest(binary=data$binary, treat=data$treat, var_est = "Pooled")
0.45/0.24
bintest <- function(binary,treat,var_est='Unpooled'){
db=cbind.data.frame(binary=binary, treat=treat)
db1=subset(db,db$treat==1)
db0=subset(db,db$treat==0)
n1=dim(db1)[1]
n0=dim(db0)[1]
n=n0+n1
# BINARY TEST
######################################
phat_group0 = sum(subset(db, db$treat==0)$binary)/n0
phat_group1 = sum(subset(db, db$treat==1)$binary)/n1
phat_pooled = (phat_group0*n0 + phat_group1*n1)/n
if(var_est=='Unpooled'){
var.bin= phat_group0*(1-phat_group0)/n0+phat_group1*(1-phat_group1)/n1
}else{
var.bin = (n/(n0*n1))*phat_pooled*(1-phat_pooled)
}
Zb = (phat_group1-phat_group0)/sqrt(var.bin)
# return(list=c(Test=Zb,Ub=sqrt((n0*n1)/n)*(phat_group1-phat_group0),sd=sqrt(phat_pooled*(1-phat_pooled))  ))
return(list=c(Test=Zb,Ub=sqrt((n0*n1)/n)*(phat_group1-phat_group0),sd=sqrt(var.bin/(n/(n0*n1)))  ))
}
bintest(binary=data$binary, treat=data$treat, var_est = "Pooled")
0.45/0.24
bintest(binary=data$binary, treat=data$treat, var_est = "Unpooled")
0.45/0.19
lstats_boots(data$time, data$status, data$binary, data$treat, tau=4, rho=0, gam=1, eta=1, wb=0.25, ws=0.75,
Boot = 100)
